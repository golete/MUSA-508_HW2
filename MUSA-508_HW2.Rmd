---
title: "MUSA 508, Hedonic Home Price Prediction"
author: "Ericson, E. & Le√≥n, A."
output: 
  html_document:
    code_folding: hide
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = T, warning = F, error = F, message = F, results = F)

# load libraries
# TODO: check if using gridExtra, jtools, ggstance
library(tidyverse)
library(tidycensus)
library(sf)
library(dummies) # TODO: probably remove along with dummy correlation code
library(spdep)
library(caret)
library(ckanr) # TODO: probably remove unless adding data with CKAN API
library(FNN)
library(grid)
library(gridExtra)
library(ggcorrplot)
library(kableExtra)
library(jtools)     # for regression model plots
library(ggstance) # to support jtools plots
library(mapview)
library(stargazer)

# load book functions
source("https://raw.githubusercontent.com/urbanSpatial/Public-Policy-Analytics-Landing/master/functions.r")

# set Census API key
census_api_key("e79f3706b6d61249968c6ce88794f6f556e5bf3d", overwrite = FALSE)

# block scientific notation
options(scipen = 999)

# set shortcuts
g <- glimpse
m <- mapview
palette5 <- c("#f0f9e8","#bae4bc","#7bccc4","#139ed1","#0868ac")

# set map styling options
mapTheme <- function() {
  theme(
    axis.text = element_blank(),
    axis.ticks = element_blank(),
    panel.background = element_blank(),
    plot.title = element_text(face = "bold"),
    plot.subtitle = element_text(face = "italic"),
    plot.caption = element_text(hjust = 0)
  )
}

# set plot styling options
plotTheme <- function() {
  theme(
    axis.ticks = element_blank(),
#    axis.title = element_blank(),
    legend.title = element_blank(),
    panel.background = element_blank(),
    panel.grid.major = element_line(color = "gray75", size = 0.1),
    panel.grid.minor = element_line(color = "gray75", size = 0.1),
    plot.title = element_text(face = "bold"),
    plot.subtitle = element_text(face = "italic"),
    plot.caption = element_text(hjust = 0))
}
```

## 0. Intro [PLACEHOLDER]







# 1. Data wrangling 






```{r data A: homes}

# --- DATA WRANGLING ---

# A. HOME VALUE DATA

# set Boulder CRS
boulderCRS <- "ESRI:102253" # NAD 1983 HARN StatePlane Colorado North FIPS 0501

# read in home value data
data <- st_read("studentData.geojson") %>%
  st_set_crs("ESRI:102254") %>%
  st_transform(boulderCRS) %>%
  filter(toPredict == 0)

# A1. Clean and recode home data

# recode missing data and engineered features
homeRecodes <- data %>%
  mutate(
    # calculate log of price to normalize positive skew
    logPrice = log(price),
    # recode missing construction material values
    constMat = case_when(
      ConstCode == 0 ~ "Missing",
      ConstCode == 300 ~ "Unspecified",
      ConstCode > 300 ~ as.character(ConstCodeDscr)
    ),
    # recode missing basement values
    basement = if_else(bsmtType == 0, "None", as.character(bsmtTypeDscr)),
    # recode missing car storage values
    carStorage = if_else(carStorageType == 0, "None", as.character(carStorageTypeDscr)),
    # recode missing a/c values
    acType = case_when(
      is.na(Ac) ~ "None",
      Ac == 200 ~ "Unspecified", # Code with no description
      Ac >= 210 ~ as.character(AcDscr) # "Attic Fan", "Evaporative Cooler", "Whole House" unchanged
    ),
    # recode missing heating values
    heatingType = case_when(
      is.na(Heating) ~ "None",
      Heating == 800 ~ "Unspecified",
      Heating > 800 ~ as.character(HeatingDscr)
    ),
    # recode missing primary exterior wall values
    extWall = if_else(ExtWallPrim == 0, "Missing", as.character(ExtWallDscrPrim)),
    # recode missing secondary exterior wall values
    extWall2 = if_else(is.na(ExtWallSec), "None", as.character(ExtWallDscrSec)),
    # recode missing interior wall values
    intWall = if_else(is.na(IntWall), "Missing", as.character(IntWallDscr)),
    # recode missing roof cover values
    roofType = if_else(is.na(Roof_Cover), "Missing", as.character(Roof_CoverDscr)),
    # recode quality as numeric variable
    qualityNum = case_when(
      qualityCode == 10 ~ 1, # QualityCodeDscr == "LOW "
      qualityCode == 20 ~ 2, # "FAIR "
      qualityCode == 30 ~ 3, # "AVERAGE "
      qualityCode == 31 ~ 4, # "AVERAGE + "
      qualityCode == 32 ~ 5, # "AVERAGE ++ "
      qualityCode == 40 ~ 6, # "GOOD "
      qualityCode == 41 ~ 7, # "GOOD + "
      qualityCode == 42 ~ 8, # "GOOD ++ "
      qualityCode == 50 ~ 9, # "VERY GOOD "
      qualityCode == 51 ~ 10, # "VERY GOOD + "
      qualityCode == 52 ~ 11, # "VERY GOOD ++ "
      qualityCode == 60 ~ 12, # "EXCELLENT "
      qualityCode == 61 ~ 13, # "EXCELLENT + "
      qualityCode == 62 ~ 14, # "EXCELLENT++ "
      qualityCode == 70 ~ 15, # "EXCEPTIONAL 1 "
      qualityCode == 80 ~ 16, # "EXCEPTIONAL 2 "
    ),
    # recode missing construction material values
    constMat = case_when(
      ConstCode == 0 ~ "Missing",
      ConstCode == 300 ~ "Unspecified",
      ConstCode > 300 ~ as.character(ConstCodeDscr)
    ),
    # recode missing primary exterior wall values
    extWall = if_else(
      is.na(ExtWallPrim) | ExtWallPrim == 0, "Missing", 
      as.character(ExtWallDscrPrim)
      ),
    # recode builtYear as builtEra
    builtEra = case_when(
      builtYear < 1910 ~ "Pre-1910",
      between(builtYear, 1910, 1919) ~ "1910s",
      between(builtYear, 1920, 1929) ~ "1920s",
      between(builtYear, 1930, 1939) ~ "1930s",
      between(builtYear, 1940, 1949) ~ "1940s",
      between(builtYear, 1950, 1959) ~ "1950s",
      between(builtYear, 1960, 1969) ~ "1960s",
      between(builtYear, 1970, 1979) ~ "1970s",
      between(builtYear, 1980, 1989) ~ "1980s",
      between(builtYear, 1990, 1999) ~ "1990s",
      between(builtYear, 2000, 2009) ~ "2000s",
      between(builtYear, 2010, 2019) ~ "2010s",
      builtYear >= 2020 ~ "2020s"
    ),
    # recode section_num as manySections
    manySections = if_else(section_num > 1, 1, 0),
    # calculate total rooms, including baths
    nbrRooms = nbrBedRoom+nbrRoomsNobath+nbrFullBaths+nbrThreeQtrBaths+(nbrHalfBaths/2),
    # separate quarter sold from year sold
    quarterSold = str_sub(year_quarter, -1, -1)
    # calculate age and effective age (time since last major renovation)
    # age = year - builtYear,
    # effectiveAge = if_else(year <= builtYear, 0, year - EffectiveYear), # negative values recoded as 0
    # try simpler basement and garage categories
    # basementDummy = if_else(bsmtType == 0, 0, 1),
    # garageDummy = if_else(str_detect(carStorageTypeDscr, "GARAGE"), 1, 0)
  )
  
# TODO: remove? did not see used anywhere else
varsAnum <- 
  c('price',
  'logPrice',
  'MUSA_ID', 
  'toPredict',   
  'geometry')

# TODO: remove? did not see used anywhere else
varsAcat <- 
  c('TotalFinishedSF',
  'nbrRooms',
  'totalBaths',
  'btrRatio ',
  'quarterSold',
  'qualityNum',
  'age',
  'effectiveAge',
  'builtEra',
  'designCodeDscr',
  'basementDummy',
  'garageDummy',
  'constMat',
  'extWall')

# create clean data frame for modeling
homeData <- homeRecodes %>%
  # drop extreme outliers identified as data entry errors
  filter(!MUSA_ID %in% c(8735,1397,5258)) %>%
  # drop unneeded columns
  dplyr::select(
    # same for all
    -bldgClass,
    -bldgClassDscr,
    -status_cd,
    # not needed
    -saleDate,
    -address,
    # too much missing data
    -Stories,
    -UnitCount,
    # cleaned
    -designCode,
    -qualityCode,
    -ConstCode,
    -ConstCodeDscr,
    -bsmtType,
    -bsmtTypeDscr,
    -carStorageType,
    -carStorageTypeDscr,
    -Ac,
    -AcDscr,
    -Heating,
    -HeatingDscr,
    -ExtWallPrim,
    -ExtWallDscrPrim,
    -ExtWallSec,
    -ExtWallDscrSec,
    -IntWall,
    -IntWallDscr,
    -Roof_Cover,
    -Roof_CoverDscr,
    # recoded
    -qualityCodeDscr,
    -builtYear
  )

# isolate home IDs to use in spatial joins
homeIDs <- data %>%
  dplyr::select(MUSA_ID, geometry)

```



```{r data B: boundaries}

# B. BOUNDARY DATA (Neighborhoods, school districts, city, etc.)

# B1. Boulder county boundaries

# TODO: delete if we don't actually use
countyLimits <- st_read('County_Boundary.geojson') %>%
  select(OBJECTID, geometry)

# TODO: delete if we don't actually use
munis <- st_read('Municipalities.geojson') %>%
  select(ZONEDESC, geometry)
# CRS: EPSG: 4326, WGS84, metres


# B2. Boulder city and other cities/zones boundaries

zones <- st_read('Zoning_-_Zoning_Districts.geojson') %>%
  st_transform(boulderCRS) %>%
  select(ZONEDESC, geometry) %>%
  filter(ZONEDESC != 'Boulder') %>%
  group_by(ZONEDESC) %>%
  rename(SUBCOMMUNITY = ZONEDESC) %>%
  summarize(geometry = st_union(geometry))

# Subset the generic zones as a separate map just if needed
genericZones <- c('Business',
                  'Commercial',
                  'Economic Development',
                  'Estate Residential',
                  'General Industrial',
                  'Light Industrial',
                  'Manufactured Home',
                  'Mountain Institutional',
                  'Multiple Family',
                  'Rural Residential',
                  'Suburban Residential',
                  'Transitional')
notNamedZones <- zones %>%
  filter(SUBCOMMUNITY %in% genericZones)

# Union the polygons that are not in boulder City limits, just in case
notCity <- zones %>% st_union()


# B3. Boulder City Zoning Districts
districts <- st_read('Zoning_Districts.geojson') %>%
  st_transform(boulderCRS) %>%
  select(OBJECTID, ZONING, ZNDESC, geometry)

# Load the subcommunities / neighborhoods rough boundaries
subcomms <-  st_read('Subcommunities.geojson') %>%
  st_transform(boulderCRS)


# Join the region zoning polygons with the subcommunities polygons and union
cityHoods <- st_join(districts, subcomms, largest=TRUE) %>%
  select(SUBCOMMUNITY, geometry) %>%
  group_by(SUBCOMMUNITY) %>%
  summarize(geometry = st_union(geometry))


# FINAL NEIGHBORHOOD DATA TO USE
neighborhoods <- rbind(zones, cityHoods) %>%
  rename(community = SUBCOMMUNITY)

neighborhoodData <- st_join(homeIDs, neighborhoods) %>%
  distinct(.,MUSA_ID, .keep_all = TRUE) %>%
  st_drop_geometry() 

```



```{r data C: Census}

# C. CENSUS DATA

year <- 2019
state <- 08
county <- 13

# review available variables
acsVariableList <- load_variables(year,"acs5", cache = TRUE)

# define variables to import
varsC <- c("B02001_001E", # race: total
           "B02001_002E", # race: white alone
           'B25003_001E', # tenure: occupied housing units
           'B25003_002E', # tenure: owner-occupied
           'B25002_001E', # occupancy: total housing units
           'B25002_003E', # occupancy: vacant housing units
           'B15003_001E', # educational attainment: total
           'B15003_022E', # educational attainment: bachelor's degree
           'B15003_023E', # educational attainment: master's degree
           'B15003_024E', # educational attainment: professional degree
           'B15003_025E', # educational attainment: doctorate degree
           'B19001_001E', # household income: total
           'B19001_002E', # household income: less than $10k
           'B19001_003E', # household income: $10-15k
           'B19001_004E', # household income: $15-20k
           'B19001_005E', # household income: $20-25k
           'B19001_006E', # household income: $25-30k
           'B19001_007E', # household income: $30-35k
           'B19001_008E', # household income: $35-40k
           'B19001_009E', # household income: $40-45k
           'B19001_010E', # household income: $45-50k
           'B19001_011E', # household income: $50-60k
           'B19001_012E', # household income: $60-75k
           'B19001_013E', # household income: $75-100k
           'B19001_014E', # household income: $100-125k
           'B19001_015E', # household income: $125-150k
           'B19001_016E', # household income: $150-200k
           'B19001_017E') # household income: $200 or more

# import variables from ACS 2019 5-year
blockGroups <- 
  get_acs(geography = "block group",
          variables = varsC,
          year = year,
          state = state,
          county = county,
          geometry = T,
          output = 'wide') %>%
  dplyr::select(-ends_with('M')) %>%
  rename(# white population
         raceTotal = B02001_001E, # race: total
         whiteAlone = B02001_002E, # race: white alone
         # vacant housing units
         totalUnits = B25002_001E, # occupancy status: total
         vacantUnits = B25002_003E, # occupancy status: vacant
         # homeowners
         occupiedUnits = B25003_001E, # tenure: total
         ownerOccupied = B25003_002E, # tenure: owner-occupied
         # highest educational attainment
         eduTotal = B15003_001E, # educational attainment: total
         eduBachs = B15003_022E, # educational attainment: bachelor's degree
         eduMasts = B15003_023E, # educational attainment: master's degree
         eduProfs = B15003_024E, # educational attainment: professional degree
         eduDocts = B15003_025E, # educational attainment: doctorate degree
         # household income
         incomeTotal = B19001_001E, # household income: total
         income000 = B19001_002E, # household income: less than $10k
         income010 = B19001_003E, # household income: $10-15k
         income015 = B19001_004E, # household income: $15-20k
         income020 = B19001_005E, # household income: $20-25k
         income025 = B19001_006E, # household income: $25-30k
         income030 = B19001_007E, # household income: $30-35k
         income035 = B19001_008E, # household income: $35-40k
         income040 = B19001_009E, # household income: $40-45k
         income045 = B19001_010E, # household income: $45-50k
         income050 = B19001_011E, # household income: $50-60k
         income060 = B19001_012E, # household income: $60-75k
         income075 = B19001_013E, # household income: $75-100k
         income100 = B19001_014E, # household income: $100-125k
         income125 = B19001_015E, # household income: $125-150k
         income150 = B19001_016E, # household income: $150-200k
         income200 = B19001_017E # household income: $200k or more
         )%>%
  mutate(pctWhite = whiteAlone/raceTotal,
         pctVacant = vacantUnits/totalUnits,
         pctOwnerOccupied = ownerOccupied/occupiedUnits,
         # calculate percent with bachelor's or higher
         # TODO: compare percent postgraduate?
         pctHigherEdu = if_else(
           eduTotal > 0, (eduBachs + eduMasts + eduProfs + eduDocts)/eduTotal, 0
         ),
         # calculate percent in each income category
         pctIncome000 = income000/incomeTotal,
         pctIncome010 = income010/incomeTotal,
         pctIncome015 = income015/incomeTotal,
         pctIncome020 = income020/incomeTotal,
         pctIncome025 = income025/incomeTotal,
         pctIncome030 = income030/incomeTotal,
         pctIncome035 = income035/incomeTotal,
         pctIncome040 = income040/incomeTotal,
         pctIncome045 = income045/incomeTotal,
         pctIncome050 = income050/incomeTotal,
         pctIncome060 = income060/incomeTotal,
         pctIncome075 = income075/incomeTotal,
         pctIncome100 = income100/incomeTotal,
         pctIncome125 = income125/incomeTotal,
         pctIncome150 = income150/incomeTotal,
         pctIncome200 = income200/incomeTotal) %>%
  select(-raceTotal, -occupiedUnits, -totalUnits, -vacantUnits, -ownerOccupied,-whiteAlone,
         -starts_with('edu'), -starts_with('income')) %>%
  rename(block = GEOID) %>%
  st_transform(boulderCRS)

blockGroupBoundaries <- blockGroups %>%
  select(block, geometry)

censusData <- st_join(homeIDs, blockGroupBoundaries) %>%
  st_drop_geometry() %>%
  left_join(., blockGroups, by='block') %>%
  select(-NAME, -geometry)

# import tract boundaries as proxy for neighborhoods
tracts <- 
  get_acs(geography = "tract",
          variables = 'B25003_001E',
          year = year,
          state = state,
          county = county,
          geometry = T,
          output = 'wide') %>%
  dplyr::select(GEOID, geometry)%>%
  rename(tract = GEOID) %>%
  st_transform(boulderCRS)

tractsData <- st_join(homeIDs, tracts) %>%
  st_drop_geometry()

```


```{r data D: other data}

# D. OTHER DATA (CRIME, FEMA, etc.)

# D1. Wildfire history data

wildfires <-
  st_read('Wildfire_History.geojson') %>%
  filter(ENDDATE > "2001-10-19 00:00:00") %>% # FILTER to only fires that happened after 2000
  select(NAME, geometry) %>%
  st_transform(boulderCRS) %>%
  st_buffer(1610) %>%
  st_union() %>%
  st_sf() %>%
  mutate(wildfireHazard = 1)

wildfireData <- st_join(homeIDs, wildfires) %>%
  st_drop_geometry() %>%
  mutate(wildfireHazard = replace_na(wildfireHazard, 0))


# D2. CHAMP floodplain maps

fldrisk = c(AE = 4, AH = 3, AO = 2, X = 1)

floodplains <- 
  st_read('Floodplain_-_BC_Regulated.geojson') %>%
  st_transform(boulderCRS) %>%
  select(SFHA_TF, #Special Flood Hazard Area. If the area is within the SFHA.
         FLD_ZONE, #Flood Zone. This is a flood zone designation.
         geometry) %>%
  mutate(FLD_ZONE = recode(FLD_ZONE, !!!fldrisk, .default = 0)) %>%
  group_by(FLD_ZONE) %>%
  summarize(geometry = st_union(geometry))%>%
  rename(floodRisk = FLD_ZONE)

floodData <- st_join(homeIDs, floodplains) %>%
  st_drop_geometry() %>%
  mutate(floodRisk = replace_na(floodRisk, 0))

```



```{r data E: experimental}

# E1. Whole Foods locations

wholeFoodsLocations <- st_read("wholefoodsmarkets_boulderCO.csv")

wholeFoods <- st_as_sf(wholeFoodsLocations, coords = c("lon", "lat"), crs = 4326) %>% #4326
  dplyr::select(-phone, -address) %>%
  st_buffer(4023) %>%
  st_union() %>%
  st_sf() %>%
  st_transform(boulderCRS)

wholeFoodsBuffer <- st_join(homeIDs, wholeFoods, left = FALSE) 

wholeFoodsData <- homeIDs %>%
  mutate(wholeFoods = ifelse(MUSA_ID %in% wholeFoodsBuffer$MUSA_ID, 1, 0))  %>%
  st_drop_geometry()


# E2. Marijuana dispensaries

marijuana <- st_read("Marijuana_Establishments.geojson") %>%
  dplyr::select(OBJECTID, Type, geometry) %>%
  st_buffer(1609) %>%
  st_union() %>%
  st_sf() %>%
  st_transform(boulderCRS)

marijuanaBuffer <- st_join(homeIDs, marijuana, left = FALSE) 

marijuanaData <- homeIDs %>%
  mutate(marijuana = ifelse(MUSA_ID %in% marijuanaBuffer$MUSA_ID, 1, 0)) %>%
  st_drop_geometry()


```



```{r data F: combined data}

# F. Combine data sets

joinedData <-
  left_join(homeData, neighborhoodData, by = 'MUSA_ID') %>%
  left_join(., censusData, by = 'MUSA_ID') %>%
  left_join(., wildfireData, by = 'MUSA_ID') %>%
  left_join(., floodData, by = 'MUSA_ID') %>%
  left_join(., wholeFoodsData, by = 'MUSA_ID') %>%
  left_join(., marijuanaData, by = 'MUSA_ID') %>%
  left_join(., tractsData, by = 'MUSA_ID')

```




# 2. Exploratory Analysis


```{r EDA: Initial analysis}

# 2. EXPLORATORY ANALYSIS

# Decide the geometry to use for neighborhoods
# 1 for neighborhoods and 2 for tracts

idx <- 2

geounit <- c('community', 'tract')

finalData <- joinedData %>%
  rename(neighborhood = geounit[idx]) %>%  # geometry to be used
  select(-geounit[-idx])                   # geometry not to be used

```


```{r EDA: Correlations}

# plot correlation of individual variables with home values

varsX <- c(
  'houseSize',
  'TotalFinishedSF',
  'nbrRooms',       # KEEP fn, choose between house size or this
  'qualityNum',     # KEEP
  'effectiveAge',   # KEEP
  'builtEra',       # KEEP
  'designCodeDscr', # KEEP - Good
  'basementDummy',  # KEEP fn
  'garageDummy',    # KEEP fn
  'constMat',       # KEEP Good
  'extWall'         # KEEP Good but may be colinear with constMat
  )

st_drop_geometry(finalData) %>%
  dplyr::select(logPrice, TotalFinishedSF) %>%
  pivot_longer(cols = !logPrice, names_to = "Variable", values_to = "Value") %>%
  ggplot(aes(Value, logPrice)) +
    geom_point(size = 0.5) +
    geom_smooth(method = "lm", color = "#FA7800") +
    facet_wrap(~Variable, ncol = 4, scales = "free") +
    labs(title = "Price as a function of continuous variables") +
  plotTheme()

st_drop_geometry(finalData) %>% 
  dplyr::select(logPrice, quarterSold) %>%
  mutate(quarterSold = as.factor(quarterSold)) %>%
  filter(logPrice <= 1000000) %>%
  gather(Variable, Value, -logPrice) %>% 
  ggplot(aes(Value, -logPrice)) +
  geom_bar(position = "dodge", stat = "summary", fun.y = "mean") +
  facet_wrap(~Variable, ncol = 1, scales = "free") +
  labs(title = "Price as a function of\ncategorical variables", y = "Mean_Price") +
  plotTheme() + theme(axis.text.x = element_text(angle = 45, hjust = 1))

# select numeric variables for correlation matrix
numericVars <- select_if(st_drop_geometry(finalData), is.numeric) %>%
  dplyr::select(
    # omit for more legible chart
    -toPredict,
    -MUSA_ID) %>%
  na.omit()

# create numeric variable correlation matrix and convert to data frame
corMatrix <- cor(numericVars)
corDF <- as.data.frame(as.table(corMatrix)) %>%
  rename(Cor = Freq)

# review numeric variables most correlated with price
corPrice <- filter(corDF, Var1 == "price")
corLogPrice <- filter(corDF, Var1 == "logPrice") # stronger correlations

corFinishedSF <- filter(corDF, Var1 == "TotalFinishedSF")

# generate correlation matrix chart for numeric variables
ggcorrplot(
   round(cor(numericVars), 1),
   p.mat = cor_pmat(numericVars),
   show.diag = TRUE,
   colors = c("#25cb10", "#ffffff", "#fa7800"),
   type = "lower",
   insig = "blank",
   lab =T
) +
   labs(title = "Correlation across numeric variables") +
  plotTheme()

ggcorrplot(
   round(cor(numericVars), 1),
   p.mat = cor_pmat(numericVars),
   show.diag = TRUE,
   colors = c("#25cb10", "#ffffff", "#fa7800"),
   type = "lower",
   insig = "blank"
) +
   labs(title = "Correlation across numeric variables") +
  plotTheme()


# select non-numeric variables to convert to dummies
nonNumericVars <- select_if(st_drop_geometry(finalData), Negate(is.numeric)) %>%
  na.omit()

# convert categorical variables to dummies
dummyVars <- dummy.data.frame(nonNumericVars)

# add log(price) column to dummies
dummiesWithLogPrice <- cbind(finalData$logPrice, dummyVars)

# create dummy variable correlation matrix as data frame
dummyCorDF <- as.data.frame(as.table(cor(dummiesWithLogPrice)))

# review dummy variables most correlated with price
dummyCorLogPrice <- filter(dummyCorDF, Var1 == "finalData$logPrice")%>%
  rename(Cor = Freq)

hoodDummyVars <- dummyVars %>%
  select(starts_with('neighborhood'))

# combine numeric and dummy variables
allVars <- cbind(numericVars, dummyVars)




# generate correlation matrix chart for dummy variables
# ggcorrplot(
#   round(cor(dummyVars), 1),
#   p.mat = cor_pmat(dummyVars),
#   show.diag = TRUE,
#   colors = c("#25cb10", "#ffffff", "#fa7800"),
#   type = "lower",
#   insig = "blank"
# ) +
#   labs(title = "Correlation across categorical dummy variables")
# 
# 
# 
# # This GG plot is not working
# ggcorrplot(
#   round(cor(allVars), 1),
#   p.mat = cor_pmat(allVars),
#   show.diag = TRUE,
#   colors = c("#25cb10", "#ffffff", "#fa7800"),
#   type = "lower",
#   insig = "blank"
# ) +
#   labs(title = "Correlation across all variables")


```


3. OLS Regression

```{r OLS regression}

# 3. LINEAR  and variable exclusion

finalDataReg <- lm(logPrice ~ .,
                 data = st_drop_geometry(finalData) %>%
                   dplyr::select(-price, -MUSA_ID, -toPredict))
summary(finalDataReg)

```


4. Modeling

```{r Modeling}

# 4. MODEL ESTIMATION & VALIDATION

# model 2
d2n <- finalData %>%
  dplyr::select(MUSA_ID,
                price,
                logPrice,
                nbrRooms,
                qualityNum,
                builtEra,
                # basementDummy,
                # garageDummy,
                designCodeDscr,
                extWall,
                starts_with('neigh'),
                starts_with('pctIncome'),
                pctVacant,
                pctHigherEdu,
                floodRisk,
                wholeFoods,
                toPredict,
                geometry)

# model 3
d3n <- finalData %>%
  dplyr::select(MUSA_ID,
                price,
                logPrice,
                nbrRooms,
                qualityNum,
                builtEra,
                # basementDummy,
                # garageDummy,
                designCodeDscr,
                extWall,
                starts_with('neigh'),
                starts_with('pctIncome'),
                pctVacant,
                pctHigherEdu,
                floodRisk,
                wholeFoods,
                toPredict,
                geometry) 


RegA <- lm(logPrice ~ .,
           data = (st_drop_geometry(d2n)) %>%
             dplyr::select(-price, -MUSA_ID, -toPredict))
summary(RegA)


```




```{r Model training}

# PLUG IN MODEL
regData <- d3n # Update with tested model

# Remove the toPredict homes
regData <- regData

# Split data into training (75%) and validation (25%) sets
inTrain <- createDataPartition(
  y = paste(
    regData$extWall,
    regData$floodRisk,
    regData$neighborhood
  ),
  p = 0.75, list = FALSE)

homes.training <- regData[inTrain,]
homes.test <- regData[-inTrain,]

# Estimate model on training set
reg.training <- lm(logPrice ~ .,
                   data = st_drop_geometry(regData) %>%
                     dplyr::select(-toPredict, -MUSA_ID, -price)
)
summary(reg.training)




# Calculate MAE and MAPE
homes.test <- homes.test %>%
  mutate(
    Regression = "Neighborhood effect",
    logPrice.Predict = (predict(reg.training, homes.test)),
    price.Predict = exp(logPrice.Predict),
    price.Error = price.Predict - price,
    price.AbsError = abs(price.Predict - price),
    price.APE = (abs(price.Predict - price)/price.Predict)    
  )

mean(homes.test$price.AbsError) # MAE
mean(homes.test$price.APE)      # MAPE

# Plot distribution of prediction errors

hist(homes.test$price.Error, breaks = 50) 
hist(homes.test$price.AbsError, breaks = 50)
hist(homes.test$price.APE, breaks = 50)


```


```{r k fold cross validation}

# Perform k-fold cross-validation using caret package
fitControl <- trainControl(method = "cv", number = 100)
set.seed(825)


# k-fold model training
reg.cv <- 
  train(
    logPrice ~ .,
    data = st_drop_geometry(homes.training) %>%
      dplyr::select(-toPredict, -MUSA_ID, -price),
    method = "lm", 
    trControl = fitControl, 
    na.action = na.omit
  )
reg.cv

# Plot distribution of MAE
allMAE <- reg.cv$resample[,3]
hist(allMAE, breaks = 50)

```



5. Spatial Lag [SIMPLIFY TERM]

```{r Spatial lag test}

# 5. SPATIAL LAG

coords.test <-  st_coordinates(homes.test) 
# Take value of neighbors for weighted matrix
neighborList.test <- knn2nb(knearneigh(coords.test, 5))
# Create spatial weight matrix
spatialWeights.test <- nb2listw(neighborList.test, style="W")

homes.test %>%
  mutate(lagPriceError = lag.listw(spatialWeights.test, price.Error)) %>%
  ggplot(aes(x=lagPriceError, y=price.Error)) # This doesn't plot anything

# Run the actual Moran's I
moranTest <- moran.mc(homes.test$price.Error, 
                      spatialWeights.test, nsim = 999)


# Plot of the Observed Moran's I and the permutations Moran's I distribution
ggplot(as.data.frame(moranTest$res[c(1:999)]), aes(moranTest$res[c(1:999)])) +
  geom_histogram(binwidth = 0.01) +
  geom_vline(aes(xintercept = moranTest$statistic), colour = "#FA7800",size=1) +
  scale_x_continuous(limits = c(-1, 1)) +
  labs(title="Observed and permuted Moran's I",
       subtitle= "Observed Moran's I in orange",
       x="Moran's I",
       y="Count") +
  plotTheme()

```


```{r Spatial lag test summary}

left_join(
  st_drop_geometry(homes.test) %>%
    group_by(neighborhood) %>%
    summarize(meanPrice = mean(price, na.rm = T)),
  mutate(homes.test, predict.fe = 
           predict(lm(price ~ neighborhood, data = homes.test), 
                   homes.test)) %>%
    st_drop_geometry %>%
    group_by(neighborhood) %>%
    summarize(meanPrediction = mean(predict.fe))) %>%
  kable() %>% kable_styling()

```


6. Neighborhood effects

```{r Generalizability Spatial}

# 6. NEIGHBORHOOD EFFECTS
# Calculate a baseline regression without the neighborhoods

reg.nhood <- lm(logPrice ~ ., data = as.data.frame(st_drop_geometry(homes.training)) %>% 
                  dplyr::select(-toPredict, -MUSA_ID, -price, -neighborhood))
summary(reg.nhood)


st_drop_geometry(regData)
homes.test.nhood <-
  homes.test %>%
  mutate(Regression = "Baseline regression",
         logPrice.Predict = predict(reg.nhood, homes.test), 
         price.Predict = exp(logPrice.Predict),
         price.Error = price.Predict- price,
         price.AbsError = abs(price.Predict- price),
         price.APE = (abs(price.Predict- price)) / price) 

mean(homes.test.nhood$price.AbsError) # MAE
mean(homes.test.nhood$price.APE)      # MAPE


bothRegressions <- rbind(
  dplyr::select(homes.test, starts_with("price"), Regression, neighborhood) %>%
  mutate(lagPriceError = lag.listw(spatialWeights.test, price.Error)),
  dplyr::select(homes.test.nhood, starts_with("price"), Regression, neighborhood) %>%
  mutate(lagPriceError = lag.listw(spatialWeights.test, price.Error))
  )

# Produce a table comparing non-neighborhood effects of a 'Baseline' regression
st_drop_geometry(bothRegressions) %>%
  gather(Variable, Value, -Regression, -neighborhood) %>%
  filter(Variable == "price.AbsError" | Variable == "price.APE") %>%
  group_by(Regression, Variable) %>%
    summarize(meanValue = mean(Value, na.rm = T)) %>%
    spread(Variable, meanValue) %>%
    kable()


```





```{r Neighborhood effects}


bothRegressions %>%
  dplyr::select(price.Predict, price, Regression) %>%
    ggplot(aes(price, price.Predict)) +
  geom_point() +
  stat_smooth(aes(price, price), 
             method = "lm", se = FALSE, size = 1, colour="#FA7800") + 
  stat_smooth(aes(price.Predict, price), 
              method = "lm", se = FALSE, size = 1, colour="#25CB10") +
  facet_wrap(~Regression) +
  labs(title="Predicted sale price as a function of observed price",
       subtitle="Orange line represents a perfect prediction; Green line represents prediction") +
  plotTheme()


# set neighborhood geometry
nhoods <- tracts %>%
  rename(neighborhood = geounit[idx])

st_drop_geometry(bothRegressions) %>%
  group_by(Regression, neighborhood) %>%
  summarize(mean.MAPE = mean(price.APE, na.rm = T)) %>%
  ungroup()%>%
  left_join(nhoods) %>%
  st_sf() %>%
  ggplot() + 
    geom_sf(aes(fill = mean.MAPE)) +
    geom_sf(data = bothRegressions, colour = "black", size = .5) +
    facet_wrap(~Regression) +
    scale_fill_gradient(low = palette5[1], high = palette5[5],
                        name = "MAPE") +
    labs(title = "Mean test set MAPE by neighborhood") +
    labs(title = "Census tracts") +
    mapTheme()


```




7. Generalizability [Simplify term, maybe in question form?]

```{r Generalizability Demographic}

# 7. GENERALIZABILITY TEST

# Replace with NEW INCOME DATA
incomeTest <- blockGroups %>%
  select(
         pctIncome000,
         pctIncome010,
         pctIncome015,
         pctIncome020,
         pctIncome025,
         pctIncome030,
         pctIncome035,
         pctIncome040,
         pctIncome045,
         pctIncome050,
         pctIncome060,
         pctIncome075,
         pctIncome100,
         pctIncome125,
         pctIncome150,
         pctIncome200
         ) %>%
  mutate(lowIncome =
           pctIncome000+
           pctIncome010+
           pctIncome015+
           pctIncome020+
           pctIncome025+
           pctIncome030+
           pctIncome035+
           pctIncome040+
           pctIncome045+
           pctIncome050+
           pctIncome060+
           pctIncome075,
         highIncome=
           pctIncome100,
           pctIncome125,
           pctIncome150,
           pctIncome200) %>%
  mutate(incomeContext = ifelse((lowIncome) > .5, "Low Income", "High Income")) %>%
  select(-starts_with('pctIncome'), -lowIncome, -highIncome)


# Plot the income groups division
grid.arrange(ncol = 1,
  ggplot() + geom_sf(data = na.omit(incomeTest), aes(fill = incomeContext)) +
    scale_fill_manual(values = c(palette5[4], palette5[3], palette5[2]), name="Income Context") +
    #scale_discrete(limits=dat$V1) +
    labs(title = "Income Context") +
    mapTheme() + theme(legend.position="bottom"))

m(wholeFoods)

```


```{r Generalizabiliy tables}

st_join(bothRegressions, incomeTest) %>% 
  group_by(Regression, incomeContext) %>%
  summarize(mean.MAPE = scales::percent(mean(price.APE, na.rm = T))) %>%
  st_drop_geometry() %>%
  spread(incomeContext, mean.MAPE) %>%
  kable(caption = "Test set MAPE by household income context") %>% kable_styling()


```


8. Conclusions





